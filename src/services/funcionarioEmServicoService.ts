
import { db } from "@/lib/firebase";
import { doc, updateDoc, getDoc, setDoc, Timestamp } from "firebase/firestore";
import { EtapaOS, TipoServico } from "@/types/ordens";
import { toast } from "sonner";

// Fun√ß√£o para diagnosticar o status de um funcion√°rio
export const diagnosticarStatusFuncionario = async (funcionarioId: string) => {
  try {
    console.log(`üîç Diagnosticando status do funcion√°rio ${funcionarioId}...`);
    
    const funcionarioRef = doc(db, "funcionarios", funcionarioId);
    const funcionarioDoc = await getDoc(funcionarioRef);
    
    if (!funcionarioDoc.exists()) {
      console.error("‚ùå Funcion√°rio n√£o encontrado");
      return { erro: "Funcion√°rio n√£o encontrado" };
    }
    
    const funcionarioData = funcionarioDoc.data();
    const diagnostico = {
      funcionarioId,
      nome: funcionarioData.nome,
      statusAtividade: funcionarioData.statusAtividade,
      atividadeAtual: funcionarioData.atividadeAtual,
      ordemExiste: false,
      inconsistente: false
    };
    
    // Verificar se a ordem atual existe
    if (funcionarioData.atividadeAtual?.ordemId) {
      try {
        const ordemRef = doc(db, "ordens_servico", funcionarioData.atividadeAtual.ordemId);
        const ordemDoc = await getDoc(ordemRef);
        diagnostico.ordemExiste = ordemDoc.exists();
        
        // Marcar como inconsistente se est√° ocupado mas a ordem n√£o existe
        if (funcionarioData.statusAtividade === "ocupado" && !ordemDoc.exists()) {
          diagnostico.inconsistente = true;
        }
      } catch (error) {
        console.warn("‚ö†Ô∏è Erro ao verificar ordem:", error);
        diagnostico.inconsistente = true;
      }
    }
    
    console.log("üìã Diagn√≥stico completo:", diagnostico);
    return diagnostico;
  } catch (error) {
    console.error("‚ùå Erro no diagn√≥stico:", error);
    return { erro: "Erro ao diagnosticar funcion√°rio" };
  }
};

// Fun√ß√£o para limpeza preventiva de dados inconsistentes
export const limparDadosInconsistentes = async (funcionarioId: string): Promise<boolean> => {
  try {
    console.log(`üßπ Limpando dados inconsistentes do funcion√°rio ${funcionarioId}...`);
    
    const diagnostico = await diagnosticarStatusFuncionario(funcionarioId);
    
    if (diagnostico.erro) {
      return false;
    }
    
    if (diagnostico.inconsistente) {
      console.log("üîß Dados inconsistentes detectados, limpando...");
      
      const funcionarioRef = doc(db, "funcionarios", funcionarioId);
      await updateDoc(funcionarioRef, {
        statusAtividade: "disponivel",
        atividadeAtual: null
      });
      
      // Tamb√©m limpar o registro de tracking se existir
      try {
        const emServicoRef = doc(db, "funcionarios_em_servico", funcionarioId);
        const emServicoDoc = await getDoc(emServicoRef);
        
        if (emServicoDoc.exists()) {
          await updateDoc(emServicoRef, {
            finalizado: Timestamp.now(),
            status: "limpo_automaticamente",
            observacao: "Dados inconsistentes detectados e limpos automaticamente"
          });
        }
      } catch (err) {
        console.warn("‚ö†Ô∏è Aviso: N√£o foi poss√≠vel limpar registro de tracking", err);
      }
      
      console.log("‚úÖ Dados inconsistentes limpos com sucesso");
      toast.success("Dados inconsistentes detectados e corrigidos automaticamente");
      return true;
    }
    
    console.log("‚úÖ Dados do funcion√°rio est√£o consistentes");
    return true;
  } catch (error) {
    console.error("‚ùå Erro na limpeza de dados:", error);
    return false;
  }
};

// Marcar um funcion√°rio como ocupado em um servi√ßo
export const marcarFuncionarioEmServico = async (
  funcionarioId: string,
  ordemId: string,
  etapa: EtapaOS,
  servicoTipo?: TipoServico | string
): Promise<boolean> => {
  if (!funcionarioId || !ordemId) {
    console.error("IDs de funcion√°rio ou ordem inv√°lidos", { funcionarioId, ordemId });
    toast.error("Dados inv√°lidos para marcar funcion√°rio como ocupado");
    return false;
  }

  try {
    console.log(`üîÑ Iniciando processo para marcar funcion√°rio ${funcionarioId} como ocupado na ordem ${ordemId}`);
    console.log("Par√¢metros recebidos:", { funcionarioId, ordemId, etapa, servicoTipo });
    
    // Verificar conex√£o com Firebase
    if (!db) {
      console.error("‚ùå Conex√£o com Firebase n√£o dispon√≠vel");
      toast.error("Erro de conex√£o com o banco de dados");
      return false;
    }
    
    console.log("‚úÖ Conex√£o com Firebase OK");
    
    // Primeiro, fazer limpeza preventiva de dados inconsistentes
    console.log("üßπ Executando limpeza preventiva...");
    await limparDadosInconsistentes(funcionarioId);
    
    // Verificar se o funcion√°rio existe
    console.log(`üìã Verificando se funcion√°rio ${funcionarioId} existe...`);
    const funcionarioRef = doc(db, "funcionarios", funcionarioId);
    
    let funcionarioDoc;
    try {
      funcionarioDoc = await getDoc(funcionarioRef);
    } catch (error: any) {
      console.error("‚ùå Erro ao buscar funcion√°rio:", error);
      console.error("‚ùå Detalhes do erro Firebase:", {
        code: error.code,
        message: error.message,
        details: error
      });
      toast.error(`Erro ao acessar dados do funcion√°rio: ${error.message || 'Erro desconhecido'}`);
      return false;
    }
    
    if (!funcionarioDoc.exists()) {
      console.error("‚ùå Funcion√°rio n√£o encontrado:", funcionarioId);
      toast.error("Funcion√°rio n√£o encontrado no sistema");
      return false;
    }
    
    const funcionarioData = funcionarioDoc.data();
    console.log("‚úÖ Funcion√°rio encontrado:", { 
      id: funcionarioId, 
      nome: funcionarioData.nome,
      statusAtividade: funcionarioData.statusAtividade,
      atividadeAtual: funcionarioData.atividadeAtual
    });
    
    // Verifica√ß√£o mais robusta do status do funcion√°rio
    const isOcupadoEmOutraOrdem = funcionarioData.statusAtividade === "ocupado" && 
                                  funcionarioData.atividadeAtual && 
                                  funcionarioData.atividadeAtual.ordemId !== ordemId;
    
    if (isOcupadoEmOutraOrdem) {
      console.warn("‚ö†Ô∏è Funcion√°rio parece estar ocupado em outra ordem:", {
        funcionarioId,
        ordemAtual: funcionarioData.atividadeAtual.ordemId,
        novaOrdem: ordemId
      });
      
      // Verificar se a ordem atual realmente existe
      console.log("üîç Verificando se a ordem atual do funcion√°rio ainda existe...");
      try {
        const ordemAtualRef = doc(db, "ordens_servico", funcionarioData.atividadeAtual.ordemId);
        const ordemAtualDoc = await getDoc(ordemAtualRef);
        
        if (!ordemAtualDoc.exists()) {
          console.log("‚ö†Ô∏è Ordem atual do funcion√°rio n√£o existe mais. Liberando funcion√°rio automaticamente...");
          // Liberar funcion√°rio automaticamente se a ordem n√£o existir
          await updateDoc(funcionarioRef, {
            statusAtividade: "disponivel",
            atividadeAtual: null
          });
          console.log("‚úÖ Funcion√°rio liberado automaticamente");
        } else {
          // A ordem existe, ent√£o o funcion√°rio realmente est√° ocupado
          const ordemNome = ordemAtualDoc.data()?.nome || 'Desconhecida';
          console.error("‚ùå Funcion√°rio realmente est√° ocupado em outra ordem v√°lida");
          
          // Mostrar mensagem de erro mais informativa com op√ß√£o de libera√ß√£o manual
          toast.error(
            `Funcion√°rio ${funcionarioData.nome} est√° ocupado na ordem "${ordemNome}" (${funcionarioData.atividadeAtual.ordemId}). ` +
            `Use a fun√ß√£o de libera√ß√£o manual se necess√°rio.`,
            {
              duration: 10000,
              action: {
                label: "Liberar Manualmente",
                onClick: () => forcarLiberacaoFuncionario(funcionarioId)
              }
            }
          );
          return false;
        }
      } catch (error: any) {
        console.warn("‚ö†Ô∏è Erro ao verificar ordem atual do funcion√°rio:", error);
        // Em caso de erro, assumir que a ordem n√£o existe e liberar funcion√°rio
        console.log("‚ö†Ô∏è Liberando funcion√°rio devido a erro na verifica√ß√£o...");
        await updateDoc(funcionarioRef, {
          statusAtividade: "disponivel",
          atividadeAtual: null
        });
        console.log("‚úÖ Funcion√°rio liberado devido a erro na verifica√ß√£o");
      }
    }
    
    // Se j√° est√° ocupado na mesma ordem, permitir (pode ser mudan√ßa de servi√ßo)
    if (funcionarioData.statusAtividade === "ocupado" && 
        funcionarioData.atividadeAtual && 
        funcionarioData.atividadeAtual.ordemId === ordemId) {
      console.log("üîÑ Funcion√°rio j√° est√° ocupado na mesma ordem, atualizando servi√ßo");
    }
    
    // Buscar o nome da ordem para salvar na atividade atual
    let ordemNome = "";
    try {
      console.log(`üìã Buscando dados da ordem ${ordemId}...`);
      const ordemRef = doc(db, "ordens_servico", ordemId);
      const ordemDoc = await getDoc(ordemRef);
      if (ordemDoc.exists()) {
        ordemNome = ordemDoc.data().nome || "";
        console.log("‚úÖ Nome da ordem encontrado:", ordemNome);
      } else {
        console.warn("‚ö†Ô∏è Ordem n√£o encontrada, mas continuando...");
      }
    } catch (e: any) {
      console.warn("‚ö†Ô∏è Erro ao buscar nome da ordem:", e);
    }
    
    // Converter servicoTipo para string de forma segura
    let servicoTipoString: string | null = null;
    if (servicoTipo !== undefined && servicoTipo !== null) {
      if (typeof servicoTipo === 'string') {
        servicoTipoString = servicoTipo;
      } else {
        // Se √© um enum TipoServico, converter para string
        servicoTipoString = String(servicoTipo);
      }
    }
    
    // Registrar a atividade atual do funcion√°rio
    const atividadeAtual = {
      ordemId,
      ordemNome,
      etapa,
      servicoTipo: servicoTipoString,
      inicio: Timestamp.now()
    };
    
    console.log("üîÑ Atualizando status do funcion√°rio para ocupado:", atividadeAtual);
    
    // Atualizar o documento do funcion√°rio
    try {
      await updateDoc(funcionarioRef, {
        statusAtividade: "ocupado",
        atividadeAtual
      });
      console.log("‚úÖ Documento do funcion√°rio atualizado com sucesso");
    } catch (error: any) {
      console.error("‚ùå Erro ao atualizar documento do funcion√°rio:", error);
      console.error("‚ùå Detalhes do erro Firebase:", {
        code: error.code,
        message: error.message,
        details: error
      });
      toast.error(`Erro ao atualizar status do funcion√°rio: ${error.message || 'Erro desconhecido'}`);
      return false;
    }
    
    // Registrar na cole√ß√£o de tracking
    try {
      console.log("üîÑ Criando registro de tracking...");
      const emServicoRef = doc(db, "funcionarios_em_servico", funcionarioId);
      await setDoc(emServicoRef, {
        funcionarioId,
        ordemId,
        ordemNome,
        etapa,
        servicoTipo: servicoTipoString,
        inicio: Timestamp.now(),
        timestamp: Timestamp.now(),
        status: "em_andamento"
      });
      console.log("‚úÖ Registro de tracking criado com sucesso");
    } catch (error: any) {
      console.error("‚ùå Erro ao criar registro de tracking:", error);
      console.error("‚ùå Detalhes do erro Firebase:", {
        code: error.code,
        message: error.message,
        details: error
      });
      console.warn("‚ö†Ô∏è Funcion√°rio foi marcado como ocupado, mas tracking falhou");
      // N√£o falhar completamente se apenas o tracking falhar
    }
    
    console.log(`‚úÖ Funcion√°rio ${funcionarioId} marcado como ocupado com sucesso na ordem ${ordemId}`);
    toast.success(`Funcion√°rio ${funcionarioData.nome} marcado como ocupado`);
    return true;
  } catch (error: any) {
    console.error("‚ùå Erro geral ao marcar funcion√°rio como ocupado:", error);
    console.error("‚ùå Detalhes do erro:", {
      message: error.message,
      code: error.code,
      stack: error.stack
    });
    toast.error(`Erro interno: ${error.message || 'Erro desconhecido'}`);
    return false;
  }
};

// Liberar um funcion√°rio quando o servi√ßo √© pausado ou conclu√≠do
export const liberarFuncionarioDeServico = async (
  funcionarioId: string
): Promise<boolean> => {
  if (!funcionarioId) {
    console.error("ID de funcion√°rio inv√°lido");
    return false;
  }
  
  try {
    console.log(`Liberando funcion√°rio ${funcionarioId} do servi√ßo`);
    
    // Atualizar o documento do funcion√°rio para registrar que est√° dispon√≠vel
    const funcionarioRef = doc(db, "funcionarios", funcionarioId);
    const funcionarioDoc = await getDoc(funcionarioRef);
    
    if (!funcionarioDoc.exists()) {
      console.error("Funcion√°rio n√£o encontrado:", funcionarioId);
      return false;
    }
    
    await updateDoc(funcionarioRef, {
      statusAtividade: "disponivel",
      atividadeAtual: null
    });
    
    // Atualizar registro da cole√ß√£o de tracking
    try {
      const emServicoRef = doc(db, "funcionarios_em_servico", funcionarioId);
      const emServicoDoc = await getDoc(emServicoRef);
      
      if (emServicoDoc.exists()) {
        await updateDoc(emServicoRef, {
          finalizado: Timestamp.now(),
          status: "finalizado"
        });
      } else {
        console.warn("Registro de tracking n√£o encontrado para o funcion√°rio:", funcionarioId);
      }
    } catch (err) {
      console.warn("Aviso: N√£o foi poss√≠vel atualizar registro de tracking", err);
      // N√£o falhar completamente se apenas o tracking falhar
    }
    
    console.log(`Funcion√°rio ${funcionarioId} liberado do servi√ßo`);
    return true;
  } catch (error) {
    console.error("Erro ao liberar funcion√°rio do servi√ßo:", error);
    return false;
  }
};

// Fun√ß√£o para for√ßar a libera√ß√£o de um funcion√°rio (usado em casos excepcionais)
export const forcarLiberacaoFuncionario = async (
  funcionarioId: string
): Promise<boolean> => {
  if (!funcionarioId) {
    console.error("ID de funcion√°rio inv√°lido");
    return false;
  }
  
  try {
    console.log(`üö® FOR√áANDO libera√ß√£o do funcion√°rio ${funcionarioId}...`);
    
    // Primeiro fazer diagn√≥stico para logging
    const diagnostico = await diagnosticarStatusFuncionario(funcionarioId);
    console.log("üìã Status antes da libera√ß√£o for√ßada:", diagnostico);
    
    // Atualizar o documento do funcion√°rio para registrar que est√° dispon√≠vel
    const funcionarioRef = doc(db, "funcionarios", funcionarioId);
    
    await updateDoc(funcionarioRef, {
      statusAtividade: "disponivel",
      atividadeAtual: null
    });
    
    // Atualizar o registro de tracking
    try {
      const emServicoRef = doc(db, "funcionarios_em_servico", funcionarioId);
      const emServicoDoc = await getDoc(emServicoRef);
      
      if (emServicoDoc.exists()) {
        await updateDoc(emServicoRef, {
          finalizado: Timestamp.now(),
          status: "finalizado_forcado",
          observacao: "Libera√ß√£o for√ßada pelo usu√°rio - poss√≠vel inconsist√™ncia de dados"
        });
      }
    } catch (err) {
      // Se n√£o encontrar o documento de tracking, n√£o √© um problema cr√≠tico
      console.warn("Aviso: N√£o foi poss√≠vel atualizar registro de tracking", err);
    }
    
    toast.success(`Funcion√°rio liberado for√ßadamente com sucesso`);
    console.log(`‚úÖ Funcion√°rio ${funcionarioId} liberado for√ßadamente`);
    return true;
  } catch (error) {
    console.error("‚ùå Erro ao for√ßar libera√ß√£o do funcion√°rio:", error);
    toast.error("Erro ao liberar funcion√°rio for√ßadamente");
    return false;
  }
};
